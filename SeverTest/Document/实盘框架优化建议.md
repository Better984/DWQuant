# Cç«¯é‡åŒ–äº§å“å®ç›˜æ¡†æ¶ä¼˜åŒ–å»ºè®®

## æ¦‚è¿°

æœ¬æ–‡æ¡£åŸºäºå½“å‰ä»£ç å®ç°ï¼Œé’ˆå¯¹Cç«¯é‡åŒ–äº§å“çš„å®ç›˜æ¡†æ¶æå‡ºä¼˜åŒ–å»ºè®®ã€‚é‡ç‚¹å…³æ³¨**å¯é æ€§ã€æ€§èƒ½ã€å¯æ‰©å±•æ€§å’Œç”¨æˆ·ä½“éªŒ**å››ä¸ªç»´åº¦ã€‚

---

## ğŸ”´ ä¼˜å…ˆçº§1ï¼šè‡´å‘½é—®é¢˜ä¿®å¤ï¼ˆå¿…é¡»ç«‹å³å¤„ç†ï¼‰

### 1.1 MarketDataTask å¤šæ¶ˆè´¹è€…åˆ†æµé—®é¢˜

**é—®é¢˜æè¿°**ï¼š
- `MarketDataEngine` åªæœ‰ä¸€ä¸ª `Channel<MarketDataTask>`
- `RealTimeStrategyEngine` å’Œ `KlineCloseListenerService` åŒæ—¶è¯»å–
- Channel å¤šè¯»è€…ä¼š"åˆ†æµ"è€Œä¸æ˜¯"å¹¿æ’­"ï¼Œå¯¼è‡´ç­–ç•¥æ‰§è¡Œæˆ–è¡Œæƒ…æ¨é€éšæœºç¼ºå¤±

**å½±å“**ï¼šç­–ç•¥å¯èƒ½é”™è¿‡Kçº¿äº‹ä»¶ï¼Œç”¨æˆ·çœ‹åˆ°çš„æ•°æ®ä¸ä¸€è‡´

**ä¼˜åŒ–æ–¹æ¡ˆ**ï¼š
```csharp
// æ–¹æ¡ˆAï¼šä¸ºæ¯ä¸ªæ¶ˆè´¹è€…å»ºç«‹ç‹¬ç«‹é€šé“ï¼ˆæ¨èï¼‰
// åœ¨ MarketDataEngine ä¸­ç»´æŠ¤å¤šä¸ª Channelï¼Œå…¥é˜Ÿæ—¶å¤åˆ¶å†™å…¥
private readonly List<Channel<MarketDataTask>> _subscriberChannels = new();

public MarketDataTaskSubscription SubscribeMarketTasks(string subscriberName)
{
    var channel = ChannelFactory.Create<MarketDataTask>(...);
    _subscriberChannels.Add(channel);
    return new MarketDataTaskSubscription(channel, subscriberName);
}

private void EnqueueMarketTask(...)
{
    var task = new MarketDataTask(...);
    foreach (var channel in _subscriberChannels)
    {
        channel.Writer.TryWrite(task); // å¹¿æ’­åˆ°æ‰€æœ‰è®¢é˜…è€…
    }
}
```

**ä»£ç ä½ç½®**ï¼š`SeverTest/Modules/MarketStreaming/Application/MarketDataEngine.cs:40`

---

### 1.2 ç­–ç•¥åŠ¨ä½œé˜Ÿåˆ—æ— äººæ¶ˆè´¹é—®é¢˜

**é—®é¢˜æè¿°**ï¼š
- `QueuedStrategyActionExecutor` åªè´Ÿè´£å…¥é˜Ÿï¼Œæ²¡æœ‰æ¶ˆè´¹è€…
- åŠ¨ä½œä»»åŠ¡æŒç»­å †ç§¯ï¼Œå¯èƒ½å¯¼è‡´ OOM
- ç­–ç•¥è§¦å‘çš„äº¤æ˜“åŠ¨ä½œæ°¸è¿œä¸ä¼šæ‰§è¡Œ

**å½±å“**ï¼šç­–ç•¥ä¿¡å·æ— æ³•è½¬åŒ–ä¸ºå®é™…äº¤æ˜“ï¼Œç”¨æˆ·èµ„é‡‘æ— æ³•æ‰§è¡Œç­–ç•¥é€»è¾‘

**ä¼˜åŒ–æ–¹æ¡ˆ**ï¼š
```csharp
// æ–¹æ¡ˆAï¼šå¢åŠ åå°æ¶ˆè´¹è€…æœåŠ¡ï¼ˆæ¨èï¼‰
public class StrategyActionConsumerHostedService : BackgroundService
{
    private readonly StrategyActionTaskQueue _queue;
    private readonly IStrategyActionExecutor _executor;
    
    protected override async Task ExecuteAsync(CancellationToken ct)
    {
        await foreach (var task in _queue.ReadAllAsync(ct))
        {
            try
            {
                await ProcessActionTaskAsync(task, ct);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "å¤„ç†åŠ¨ä½œä»»åŠ¡å¤±è´¥: {TaskId}", task.StrategyUid);
            }
        }
    }
}
```

**ä»£ç ä½ç½®**ï¼š`SeverTest/Modules/StrategyEngine/Application/QueuedStrategyActionExecutor.cs:43`

---

### 1.3 äº¤æ˜“æ‰€åˆå§‹åŒ–é˜»å¡é—®é¢˜

**é—®é¢˜æè¿°**ï¼š
- `ExchangePriceService` ç­‰å¾… `_exchanges.Count < 3` å˜æˆ 3
- ä»»æ„äº¤æ˜“æ‰€å¼‚å¸¸ä¼šå¯¼è‡´å…¨é‡ä»·æ ¼ä¸æ›´æ–°

**ä¼˜åŒ–æ–¹æ¡ˆ**ï¼š
- åªç­‰å¾…å…³é”®äº¤æ˜“æ‰€ï¼ˆå¦‚ Binanceï¼‰
- æ”¹ä¸ºé€ä¸ªäº¤æ˜“æ‰€å°±ç»ªå³å¯åŠ¨è®¢é˜…
- å¢åŠ è¶…æ—¶å’Œé™çº§ç­–ç•¥

**ä»£ç ä½ç½®**ï¼š`SeverTest/Modules/MarketStreaming/Application/ExchangePriceService.cs:64`

---

## ğŸŸ  ä¼˜å…ˆçº§2ï¼šæ€§èƒ½ä¼˜åŒ–ï¼ˆæ˜¾è‘—æå‡ç³»ç»Ÿååé‡ï¼‰

### 2.1 ç­–ç•¥æ‰§è¡Œå¹¶è¡Œåº¦ä¼˜åŒ–

**å½“å‰é—®é¢˜**ï¼š
- `Parallel.ForEach` ä½¿ç”¨ `Environment.ProcessorCount` ä½œä¸ºæœ€å¤§å¹¶è¡Œåº¦
- å¯¹äºI/Oå¯†é›†å‹ä»»åŠ¡ï¼ˆæŒ‡æ ‡è®¡ç®—ã€æ¡ä»¶è¯„ä¼°ï¼‰ï¼ŒCPUæ ¸å¿ƒæ•°ä¸æ˜¯æœ€ä¼˜é…ç½®

**ä¼˜åŒ–æ–¹æ¡ˆ**ï¼š
```csharp
// æ ¹æ®ä»»åŠ¡ç±»å‹åŠ¨æ€è°ƒæ•´å¹¶è¡Œåº¦
private int CalculateOptimalParallelism(int strategyCount)
{
    // I/Oå¯†é›†å‹ï¼šå¯ä»¥è®¾ç½®æ›´é«˜çš„å¹¶è¡Œåº¦
    // CPUå¯†é›†å‹ï¼šä½¿ç”¨ CPU æ ¸å¿ƒæ•°
    var baseParallelism = Environment.ProcessorCount;
    var ioBoundMultiplier = 2; // I/Oå¯†é›†å‹ä»»åŠ¡å¯ä»¥æ›´é«˜
    
    // ç­–ç•¥æ•°é‡è¾ƒå°‘æ—¶ï¼Œä¸éœ€è¦å¤ªå¤šå¹¶è¡Œ
    if (strategyCount < baseParallelism)
    {
        return Math.Max(1, strategyCount);
    }
    
    return Math.Min(baseParallelism * ioBoundMultiplier, strategyCount);
}
```

**ä»£ç ä½ç½®**ï¼š`SeverTest/Modules/StrategyEngine/Application/RealTimeStrategyEngine.cs:288`

---

### 2.2 æ¡ä»¶ç¼“å­˜ä¼˜åŒ–

**å½“å‰å®ç°**ï¼š
- æ¡ä»¶ç¼“å­˜ä½¿ç”¨ `ConcurrentDictionary` + `lock` åŒæ­¥
- æ¯ä¸ªæ¡ä»¶Keyéƒ½æœ‰ç‹¬ç«‹çš„é”å¯¹è±¡

**ä¼˜åŒ–æ–¹æ¡ˆ**ï¼š
```csharp
// æ–¹æ¡ˆAï¼šä½¿ç”¨è¯»å†™é”å‡å°‘é”äº‰ç”¨
private readonly ConcurrentDictionary<string, ConditionCacheEntry> _cache = new();
private readonly ReaderWriterLockSlim _cacheLock = new();

public bool TryGet(string keyId, long timestamp, out ConditionEvaluationResult result)
{
    _cacheLock.EnterReadLock();
    try
    {
        if (!_cache.TryGetValue(keyId, out var entry))
        {
            result = default;
            return false;
        }
        
        // ä½¿ç”¨ volatile è¯»å–é¿å…é”
        if (Volatile.Read(ref entry.Timestamp) != timestamp)
        {
            result = default;
            return false;
        }
        
        result = new ConditionEvaluationResult(keyId, entry.Success, entry.Message);
        return true;
    }
    finally
    {
        _cacheLock.ExitReadLock();
    }
}

// æ–¹æ¡ˆBï¼šä½¿ç”¨æ— é”æ•°æ®ç»“æ„ï¼ˆå¦‚ LockFreeCacheï¼‰
// å¯¹äºé«˜é¢‘è¯»å–åœºæ™¯ï¼Œå¯ä»¥è€ƒè™‘å®ç°æ— é”ç¼“å­˜
```

**ä»£ç ä½ç½®**ï¼š`SeverTest/Modules/StrategyEngine/Application/ConditionCacheService.cs`

---

### 2.3 æŒ‡æ ‡è®¡ç®—æ‰¹é‡ä¼˜åŒ–

**å½“å‰é—®é¢˜**ï¼š
- `UpdateIndicatorsBeforeExecute` é€ä¸ªç­–ç•¥æ”¶é›†æŒ‡æ ‡è¯·æ±‚
- ç›¸åŒæŒ‡æ ‡çš„å¤šä¸ªç­–ç•¥ä¼šé‡å¤è®¡ç®—

**ä¼˜åŒ–æ–¹æ¡ˆ**ï¼š
```csharp
// å·²å®ç°æŒ‡æ ‡è¯·æ±‚åˆå¹¶ï¼Œä½†å¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–ï¼š
// 1. æŒ‰æŒ‡æ ‡Keyåˆ†ç»„ï¼Œæ‰¹é‡è®¡ç®—
// 2. ä½¿ç”¨æŒ‡æ ‡è®¡ç®—ç¼“å­˜ï¼Œé¿å…åŒä¸€æ—¶é—´æˆ³é‡å¤è®¡ç®—
// 3. å¼‚æ­¥é¢„è®¡ç®—ä¸‹ä¸€æ ¹Kçº¿çš„æŒ‡æ ‡å€¼

private async Task UpdateIndicatorsBatchAsync(
    IEnumerable<StrategyModel> strategies, 
    MarketDataTask task)
{
    // æ”¶é›†æ‰€æœ‰æŒ‡æ ‡è¯·æ±‚å¹¶å»é‡
    var indicatorGroups = strategies
        .Where(s => IsRunnableState(s.State))
        .SelectMany(s => _indicatorRequestsByStrategy.GetValueOrDefault(s.UidCode) ?? Enumerable.Empty<IndicatorRequest>())
        .GroupBy(r => r.Key)
        .ToList();
    
    // æ‰¹é‡è®¡ç®—æŒ‡æ ‡
    var tasks = indicatorGroups.Select(async group =>
    {
        var request = group.First().WithMaxOffset(group.Max(r => r.MaxOffset));
        return await _indicatorEngine.ProcessTaskAsync(indicatorTask, ct);
    });
    
    await Task.WhenAll(tasks);
}
```

**ä»£ç ä½ç½®**ï¼š`SeverTest/Modules/StrategyEngine/Application/RealTimeStrategyEngine.cs:1002`

---

### 2.4 å†…å­˜ç®¡ç†ä¼˜åŒ–

**å½“å‰é—®é¢˜**ï¼š
- æ¡ä»¶ç¼“å­˜å¯èƒ½æ— é™å¢é•¿ï¼ˆè™½ç„¶æœ‰æ¸…ç†æœºåˆ¶ï¼‰
- å†å²Kçº¿æ•°æ®ç¼“å­˜å¯èƒ½å ç”¨å¤§é‡å†…å­˜

**ä¼˜åŒ–æ–¹æ¡ˆ**ï¼š
```csharp
// 1. å®ç°LRUç¼“å­˜æ·˜æ±°ç­–ç•¥
public class LruConditionCache
{
    private readonly ConcurrentDictionary<string, LinkedListNode<CacheEntry>> _cache;
    private readonly LinkedList<CacheEntry> _accessOrder;
    private readonly int _maxSize;
    
    public void Set(string key, ConditionEvaluationResult result)
    {
        // å¦‚æœè¶…è¿‡æœ€å¤§å¤§å°ï¼Œç§»é™¤æœ€ä¹…æœªä½¿ç”¨çš„
        if (_cache.Count >= _maxSize)
        {
            var oldest = _accessOrder.Last;
            _cache.TryRemove(oldest.Value.Key, out _);
            _accessOrder.RemoveLast();
        }
        
        // æ·»åŠ æ–°æ¡ç›®
        var node = new LinkedListNode<CacheEntry>(new CacheEntry(key, result));
        _cache[key] = node;
        _accessOrder.AddFirst(node);
    }
}

// 2. å®šæœŸæ¸…ç†è¿‡æœŸç¼“å­˜
// 3. é™åˆ¶å•ä¸ªç­–ç•¥çš„æœ€å¤§æ¡ä»¶æ•°é‡
```

---

## ğŸŸ¡ ä¼˜å…ˆçº§3ï¼šå¯é æ€§å¢å¼ºï¼ˆæå‡ç³»ç»Ÿç¨³å®šæ€§ï¼‰

### 3.1 é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶

**å½“å‰é—®é¢˜**ï¼š
- ç­–ç•¥æ‰§è¡Œå¼‚å¸¸å¯èƒ½å½±å“å…¶ä»–ç­–ç•¥
- ç¼ºå°‘é‡è¯•æœºåˆ¶å’Œé™çº§ç­–ç•¥

**ä¼˜åŒ–æ–¹æ¡ˆ**ï¼š
```csharp
private void ExecuteLogic(
    StrategyExecutionContext context,
    StrategyRuntimeGate runtimeGate,
    StrategyRunMetrics? metrics)
{
    try
    {
        // åŸæœ‰é€»è¾‘
    }
    catch (Exception ex)
    {
        // è®°å½•é”™è¯¯ä½†ä¸å½±å“å…¶ä»–ç­–ç•¥
        _logger.LogError(ex, 
            "ç­–ç•¥æ‰§è¡Œå¼‚å¸¸: {Uid} æ—¶é—´={Time}", 
            context.Strategy.UidCode,
            FormatTimestamp(context.Task.CandleTimestamp));
        
        // å¯é€‰ï¼šæ ‡è®°ç­–ç•¥ä¸ºé”™è¯¯çŠ¶æ€ï¼Œæš‚åœæ‰§è¡Œ
        // _strategyErrorTracker.MarkError(context.Strategy.UidCode);
        
        metrics?.IncrementErrorCount();
    }
}

// å¢åŠ ç­–ç•¥å¥åº·æ£€æŸ¥
public class StrategyHealthMonitor
{
    public void CheckStrategyHealth(string uidCode)
    {
        var errorCount = _errorTracker.GetErrorCount(uidCode, TimeSpan.FromMinutes(5));
        if (errorCount > 10)
        {
            // è‡ªåŠ¨æš‚åœç­–ç•¥
            _strategyStateManager.PauseStrategy(uidCode, "é”™è¯¯ç‡è¿‡é«˜");
        }
    }
}
```

**ä»£ç ä½ç½®**ï¼š`SeverTest/Modules/StrategyEngine/Application/RealTimeStrategyEngine.cs:315`

---

### 3.2 ç›‘æ§å’Œå‘Šè­¦å¢å¼º

**å½“å‰å®ç°**ï¼š
- æœ‰åŸºç¡€çš„é˜Ÿåˆ—å‹åŠ›ç›‘æ§
- ç¼ºå°‘è¯¦ç»†çš„æ€§èƒ½æŒ‡æ ‡å’Œå‘Šè­¦

**ä¼˜åŒ–æ–¹æ¡ˆ**ï¼š
```csharp
// 1. å¢åŠ è¯¦ç»†çš„æ€§èƒ½æŒ‡æ ‡æ”¶é›†
public class StrategyEngineMetrics
{
    public long TotalTasksProcessed { get; set; }
    public long TotalStrategiesExecuted { get; set; }
    public TimeSpan AverageExecutionTime { get; set; }
    public int CurrentQueueDepth { get; set; }
    public Dictionary<string, int> ErrorCountByStrategy { get; set; }
    
    // å¯¼å‡ºåˆ° Prometheus/OpenTelemetry
    public void ExportMetrics()
    {
        // ä½¿ç”¨ Metrics.NET æˆ– OpenTelemetry
    }
}

// 2. å®ç°å‘Šè­¦è§„åˆ™
public class StrategyEngineAlerting
{
    public void CheckAlerts(StrategyEngineMetrics metrics)
    {
        // é˜Ÿåˆ—ç§¯å‹å‘Šè­¦
        if (metrics.CurrentQueueDepth > 10000)
        {
            _alertService.SendAlert("ç­–ç•¥å¼•æ“é˜Ÿåˆ—ç§¯å‹ä¸¥é‡", AlertLevel.Critical);
        }
        
        // æ‰§è¡Œæ—¶é—´å‘Šè­¦
        if (metrics.AverageExecutionTime > TimeSpan.FromSeconds(5))
        {
            _alertService.SendAlert("ç­–ç•¥æ‰§è¡Œæ—¶é—´è¿‡é•¿", AlertLevel.Warning);
        }
        
        // é”™è¯¯ç‡å‘Šè­¦
        var errorRate = metrics.ErrorCountByStrategy.Values.Sum() / (double)metrics.TotalStrategiesExecuted;
        if (errorRate > 0.1) // 10%é”™è¯¯ç‡
        {
            _alertService.SendAlert($"ç­–ç•¥é”™è¯¯ç‡è¿‡é«˜: {errorRate:P2}", AlertLevel.Warning);
        }
    }
}
```

---

### 3.3 èµ„æºéš”ç¦»å’Œé™æµ

**å½“å‰é—®é¢˜**ï¼š
- ç¼ºå°‘æŒ‰ç”¨æˆ·çš„èµ„æºé…é¢ç®¡ç†
- å•ä¸ªç”¨æˆ·å¯èƒ½å ç”¨è¿‡å¤šèµ„æº

**ä¼˜åŒ–æ–¹æ¡ˆ**ï¼š
```csharp
// 1. å®ç°ç”¨æˆ·çº§åˆ«çš„èµ„æºé…é¢
public class UserResourceQuota
{
    public int MaxStrategies { get; set; } = 10;
    public int MaxConcurrentOrders { get; set; } = 5;
    public TimeSpan MaxExecutionTimePerStrategy { get; set; } = TimeSpan.FromSeconds(1);
}

// 2. åœ¨ç­–ç•¥æ‰§è¡Œå‰æ£€æŸ¥é…é¢
private bool CheckUserQuota(string userId, StrategyModel strategy)
{
    var quota = _quotaService.GetQuota(userId);
    var userStrategyCount = GetUserStrategyCount(userId);
    
    if (userStrategyCount >= quota.MaxStrategies)
    {
        _logger.LogWarning("ç”¨æˆ· {UserId} ç­–ç•¥æ•°é‡è¶…é™", userId);
        return false;
    }
    
    return true;
}

// 3. å®ç°ç”¨æˆ·çº§åˆ«çš„é™æµ
public class UserRateLimiter
{
    private readonly ConcurrentDictionary<string, TokenBucket> _userBuckets = new();
    
    public bool AllowStrategyExecution(string userId)
    {
        var bucket = _userBuckets.GetOrAdd(userId, _ => new TokenBucket(10, TimeSpan.FromSeconds(1)));
        return bucket.TryConsume();
    }
}
```

---

## ğŸŸ¢ ä¼˜å…ˆçº§4ï¼šCç«¯äº§å“ç‰¹æ€§ä¼˜åŒ–ï¼ˆæå‡ç”¨æˆ·ä½“éªŒï¼‰

### 4.1 ç­–ç•¥æ‰§è¡Œä¼˜å…ˆçº§

**ä¼˜åŒ–æ–¹æ¡ˆ**ï¼š
```csharp
// ä¸ºç­–ç•¥æ·»åŠ ä¼˜å…ˆçº§å­—æ®µ
public enum StrategyPriority
{
    Low = 0,
    Normal = 1,
    High = 2,
    Critical = 3
}

// æŒ‰ä¼˜å…ˆçº§æ‰§è¡Œç­–ç•¥
private void HandleTask(MarketDataTask task)
{
    var strategies = GetStrategiesForTask(task)
        .OrderByDescending(s => s.Priority)
        .ThenBy(s => s.UidCode)
        .ToList();
    
    // é«˜ä¼˜å…ˆçº§ç­–ç•¥å…ˆæ‰§è¡Œ
    var highPriorityStrategies = strategies.Where(s => s.Priority >= StrategyPriority.High);
    var normalStrategies = strategies.Where(s => s.Priority < StrategyPriority.High);
    
    ExecuteStrategies(highPriorityStrategies, task);
    ExecuteStrategies(normalStrategies, task);
}
```

---

### 4.2 ç­–ç•¥æ‰§è¡Œæ—¶é—´ç»Ÿè®¡

**ä¼˜åŒ–æ–¹æ¡ˆ**ï¼š
```csharp
// è®°å½•æ¯ä¸ªç­–ç•¥çš„æ‰§è¡Œæ—¶é—´ï¼Œç”¨äºç”¨æˆ·æŸ¥çœ‹
public class StrategyExecutionStats
{
    public string StrategyUid { get; set; }
    public TimeSpan AverageExecutionTime { get; set; }
    public TimeSpan MaxExecutionTime { get; set; }
    public int ExecutionCount { get; set; }
    public DateTime LastExecutionTime { get; set; }
}

// åœ¨ç­–ç•¥æ‰§è¡Œæ—¶è®°å½•
private void ExecuteLogic(...)
{
    var stopwatch = Stopwatch.StartNew();
    try
    {
        // æ‰§è¡Œé€»è¾‘
    }
    finally
    {
        stopwatch.Stop();
        _executionStats.RecordExecution(context.Strategy.UidCode, stopwatch.Elapsed);
    }
}
```

---

### 4.3 ç­–ç•¥æ‰§è¡Œç»“æœåé¦ˆ

**ä¼˜åŒ–æ–¹æ¡ˆ**ï¼š
```csharp
// ä¸ºç­–ç•¥æ‰§è¡Œç»“æœæ·»åŠ æ›´è¯¦ç»†çš„åé¦ˆ
public class StrategyExecutionResult
{
    public bool Success { get; set; }
    public string StrategyUid { get; set; }
    public List<ConditionEvaluationResult> ConditionResults { get; set; }
    public List<ActionExecutionResult> ActionResults { get; set; }
    public TimeSpan ExecutionTime { get; set; }
    public string ErrorMessage { get; set; }
}

// é€šè¿‡WebSocketå®æ—¶æ¨é€æ‰§è¡Œç»“æœç»™ç”¨æˆ·
private async Task NotifyUserAsync(string userId, StrategyExecutionResult result)
{
    await _webSocketService.SendToUserAsync(userId, new
    {
        Type = "StrategyExecutionResult",
        Data = result
    });
}
```

---

### 4.4 ç­–ç•¥æ‰§è¡Œå†å²è®°å½•

**ä¼˜åŒ–æ–¹æ¡ˆ**ï¼š
```csharp
// ä¿å­˜ç­–ç•¥æ‰§è¡Œå†å²ï¼Œæ”¯æŒç”¨æˆ·æŸ¥çœ‹å’Œå›æ”¾
public class StrategyExecutionHistory
{
    public string StrategyUid { get; set; }
    public DateTime ExecutionTime { get; set; }
    public MarketDataTask Task { get; set; }
    public StrategyExecutionResult Result { get; set; }
    public Dictionary<string, object> Context { get; set; }
}

// å®šæœŸæ¸…ç†æ—§å†å²è®°å½•
public class StrategyExecutionHistoryCleanupService : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken ct)
    {
        while (!ct.IsCancellationRequested)
        {
            // åˆ é™¤30å¤©å‰çš„å†å²è®°å½•
            var cutoffDate = DateTime.UtcNow.AddDays(-30);
            await _historyRepository.DeleteBeforeAsync(cutoffDate, ct);
            
            await Task.Delay(TimeSpan.FromHours(24), ct);
        }
    }
}
```

---

## ğŸ”µ ä¼˜å…ˆçº§5ï¼šæ¶æ„ä¼˜åŒ–ï¼ˆé•¿æœŸæ”¹è¿›ï¼‰

### 5.1 å¾®æœåŠ¡åŒ–æ‹†åˆ†

**å»ºè®®**ï¼š
- å°†ç­–ç•¥å¼•æ“ã€å¸‚åœºæ•°æ®ã€äº¤æ˜“æ‰§è¡Œæ‹†åˆ†ä¸ºç‹¬ç«‹æœåŠ¡
- ä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—ï¼ˆå¦‚ RabbitMQ/Kafkaï¼‰è¿›è¡ŒæœåŠ¡é—´é€šä¿¡
- æ”¯æŒæ°´å¹³æ‰©å±•å’Œç‹¬ç«‹éƒ¨ç½²

---

### 5.2 åˆ†å¸ƒå¼ç­–ç•¥æ‰§è¡Œ

**å»ºè®®**ï¼š
- æ”¯æŒå¤šå®ä¾‹éƒ¨ç½²ç­–ç•¥å¼•æ“
- ä½¿ç”¨Redisåˆ†å¸ƒå¼é”ç¡®ä¿åŒä¸€ç­–ç•¥åªåœ¨ä¸€ä¸ªå®ä¾‹æ‰§è¡Œ
- å®ç°ç­–ç•¥è´Ÿè½½å‡è¡¡

**å½“å‰å·²æœ‰**ï¼š`StrategyOwnershipService` å·²å®ç°ç­–ç•¥ç§Ÿçº¦ç®¡ç†ï¼Œå¯ä»¥åœ¨æ­¤åŸºç¡€ä¸Šæ‰©å±•

---

### 5.3 æ•°æ®æŒä¹…åŒ–ä¼˜åŒ–

**å»ºè®®**ï¼š
- ç­–ç•¥æ‰§è¡Œæ—¥å¿—å¼‚æ­¥æ‰¹é‡å†™å…¥æ•°æ®åº“
- ä½¿ç”¨æ—¶é—´åºåˆ—æ•°æ®åº“ï¼ˆå¦‚ InfluxDBï¼‰å­˜å‚¨æ€§èƒ½æŒ‡æ ‡
- å®ç°æ•°æ®å½’æ¡£ç­–ç•¥

---

## å®æ–½å»ºè®®

### é˜¶æ®µ1ï¼ˆç«‹å³å®æ–½ï¼‰
1. âœ… ä¿®å¤è‡´å‘½é—®é¢˜ï¼ˆ1.1, 1.2, 1.3ï¼‰
2. âœ… å¢åŠ ç­–ç•¥åŠ¨ä½œé˜Ÿåˆ—æ¶ˆè´¹è€…
3. âœ… ä¿®å¤MarketDataTaskå¤šæ¶ˆè´¹è€…é—®é¢˜

### é˜¶æ®µ2ï¼ˆ1-2å‘¨å†…ï¼‰
1. âœ… æ€§èƒ½ä¼˜åŒ–ï¼ˆ2.1, 2.2, 2.3ï¼‰
2. âœ… é”™è¯¯å¤„ç†å¢å¼ºï¼ˆ3.1ï¼‰
3. âœ… ç›‘æ§å‘Šè­¦å®Œå–„ï¼ˆ3.2ï¼‰

### é˜¶æ®µ3ï¼ˆ1ä¸ªæœˆå†…ï¼‰
1. âœ… èµ„æºéš”ç¦»å’Œé™æµï¼ˆ3.3ï¼‰
2. âœ… Cç«¯ç‰¹æ€§ä¼˜åŒ–ï¼ˆ4.1-4.4ï¼‰
3. âœ… æ¶æ„ä¼˜åŒ–å‡†å¤‡ï¼ˆ5.1-5.3ï¼‰

---

## æ€»ç»“

å½“å‰å®ç›˜æ¡†æ¶å·²ç»å…·å¤‡è‰¯å¥½çš„åŸºç¡€æ¶æ„ï¼ˆæ¡ä»¶ç¼“å­˜ã€æŒ‡æ ‡å¼•æ“ã€ä»»åŠ¡é˜Ÿåˆ—ç­‰ï¼‰ï¼Œä½†åœ¨**å¯é æ€§ã€ç›‘æ§å’ŒCç«¯ç‰¹æ€§**æ–¹é¢è¿˜æœ‰è¾ƒå¤§æå‡ç©ºé—´ã€‚

**å…³é”®ä¼˜åŒ–ç‚¹**ï¼š
1. ğŸ”´ **å¿…é¡»ä¿®å¤**ï¼šå¤šæ¶ˆè´¹è€…åˆ†æµã€åŠ¨ä½œé˜Ÿåˆ—æ¶ˆè´¹ã€åˆå§‹åŒ–é˜»å¡
2. ğŸŸ  **æ€§èƒ½æå‡**ï¼šå¹¶è¡Œåº¦ä¼˜åŒ–ã€ç¼“å­˜ä¼˜åŒ–ã€æ‰¹é‡å¤„ç†
3. ğŸŸ¡ **å¯é æ€§**ï¼šé”™è¯¯å¤„ç†ã€ç›‘æ§å‘Šè­¦ã€èµ„æºéš”ç¦»
4. ğŸŸ¢ **ç”¨æˆ·ä½“éªŒ**ï¼šæ‰§è¡Œç»Ÿè®¡ã€ç»“æœåé¦ˆã€å†å²è®°å½•

å»ºè®®æŒ‰ç…§ä¼˜å…ˆçº§é€æ­¥å®æ–½ï¼Œç¡®ä¿ç³»ç»Ÿç¨³å®šæ€§çš„åŒæ—¶æå‡ç”¨æˆ·ä½“éªŒã€‚
