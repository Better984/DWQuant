# 前端策略创建与后端实盘

> 目的：说明前端“创建策略”的配置流程，以及后端实盘运行的实际链路（以当前代码实现为准）。

---

## 一、前端创建策略流程（Strategy Editor）

### 1) 入口与整体结构

- 入口在策略模块页签“创建策略”，用户点击自定义创建后打开编辑流程。
- 编辑流程由 `StrategyEditorFlow` 统一编排。
- `StrategyEditorShell` 仅提供头部/主体/底部布局与按钮（关闭/生成配置），本身不含业务状态。

涉及文件：
- `Client/src/components/StrategyModule.tsx`
- `Client/src/components/StrategyEditorFlow.tsx`
- `Client/src/components/StrategyEditorShell.tsx`

### 2) 指标选择与生成

- 点击“新增指标”打开指标生成器，载入 `talib_indicators_config.json`。
- 指标生成后会形成 `refType: "Indicator"` 的配置（包含 timeframe / input / params / output / offsetRange / calcMode）。
- 生成的指标会被加入“已选指标”列表，供条件编辑时引用。

涉及文件：
- `Client/src/components/IndicatorGeneratorSelector.tsx`
- `Client/public/talib_indicators_config.json`
- `Client/src/components/StrategyIndicatorPanel.tsx`

### 3) 条件容器与条件组

- 默认 4 个条件容器：开多 / 开空 / 平多 / 平空。
- 每个容器最多 3 个条件组；每组最多 6 个条件判断。
- 条件支持：启用/必需、比较方法（>= / < / <= / = / CrossOver）、左右值（指标字段或数字）。

涉及文件：
- `Client/src/components/StrategyEditorFlow.tsx`
- `Client/src/components/ConditionContainerList.tsx`
- `Client/src/components/ConditionEditorDialog.tsx`

### 4) 交易规则配置与生成 JSON

- 点击“生成配置”打开预览弹窗：可在“条件概览”和 JSON 之间切换。
- 交易规则配置内容包括：交易所、交易对、周期、单次开仓数量、最大持仓、杠杆、止盈/止损/移动止盈。
- 最终生成 `StrategyConfig`：
  - `trade`: 交易规则
  - `logic`: 逻辑分支（entry/exit, long/short）

涉及文件：
- `Client/src/components/StrategyConfigDialog.tsx`
- `Client/src/components/TradeConfigForm.tsx`
- `Client/src/components/StrategyModule.types.ts`

### 5) 提交与保存

- 前端调用 `POST /api/strategy/create`，提交 name/description/aliasName/configJson。
- 成功后触发提示并刷新策略列表。

涉及文件：
- `Client/src/components/StrategyModule.tsx`
- `SeverTest/Controllers/StrategyController.cs`

---

## 二、后端实盘运行链路（Server Runtime）

### 1) 策略创建入库

`POST /api/strategy/create`：
- 新建 `strategy_def`
- 新建 `strategy_version`（version_no=1）
- 新建 `user_strategy`（state=completed, visibility=private）
- 更新 `strategy_def.latest_version_id`

涉及文件：
- `SeverTest/Controllers/StrategyController.cs`
- `SeverTest/Document/策略系统.md`

### 2) 运行状态切换（关键入口）

`PATCH /api/strategy/instances/{id}/state`：
- state=running / paused_open_position：解析 config_json -> 组装 StrategyDocument -> 加载为运行时策略 -> 注册到 `RealTimeStrategyEngine`
- state=paused / completed：从 `RealTimeStrategyEngine` 移除
- 可选传 `exchangeApiKeyId`：绑定该策略实例使用的交易所 API key
- 未传时会自动回填该交易所最新 API key（updated_at DESC）；无可用 API 时返回错误
- 若 API key 所属交易所与策略配置不一致，会自动创建新版本并同步 `trade.exchange`

涉及文件：
- `SeverTest/Controllers/StrategyController.cs`
- `SeverTest/Services/StrategyJsonLoader.cs`
- `SeverTest/Services/RealTimeStrategyEngine.cs`

### 3) 行情驱动与执行主链路

- `MarketDataEngine` 产出行情任务（MarketDataTask）。
- `StrategyRuntimeHostedService` 启动指标引擎与策略引擎 worker。
- `RealTimeStrategyEngine` 收到行情任务后：
  1) 刷新指标（IndicatorEngine）
  2) 条件判断（ConditionEvaluator + ConditionMethodRegistry）
  3) 触发动作（ActionMethodRegistry -> IStrategyActionExecutor）

涉及文件：
- `SeverTest/Services/StrategyRuntimeHostedService.cs`
- `SeverTest/Services/RealTimeStrategyEngine.cs`
- `SeverTest/Services/IndicatorEngine.cs`
- `SeverTest/Services/ConditionEvaluator.cs`
- `SeverTest/Strategy/ConditionMethodRegistry.cs`
- `SeverTest/Strategy/ActionMethodRegistry.cs`

### 4) 下单与持仓落地

- 当前默认执行器为 `QueuedStrategyActionExecutor`，会把 `StrategyActionTask` 入队。
- `TradeActionConsumer` 消费队列，调用 `CcxtOrderExecutor` 市价下单。
- 开仓成功后写入 `strategy_position`。

涉及文件：
- `SeverTest/Services/QueuedStrategyActionExecutor.cs`
- `SeverTest/Services/StrategyActionTaskQueue.cs`
- `SeverTest/Services/TradeActionConsumer.cs`
- `SeverTest/Services/CcxtOrderExecutor.cs`
- `SeverTest/Infrastructure/Repositories/StrategyPositionRepository.cs`

### 5) 风控平仓（止盈/止损/移动止盈）

- `PositionRiskEngine` 周期性扫描未平仓位，结合 TP/SL/Trailing 触发平仓。
- 平仓后更新 `strategy_position` 状态。

涉及文件：
- `SeverTest/Services/PositionRiskEngine.cs`

---

## 三、当前实现注意点（与策略运行强相关）

1) **Short 分支未启用**
- `exit.short` / `entry.short` 在策略引擎中仍被注释，当前只执行 Long 分支。
- 涉及文件：`SeverTest/Services/RealTimeStrategyEngine.cs`

2) **启动时自动加载 DB 中运行策略**
- `StrategyRuntimeBootstrapHostedService` 启动时加载 `user_strategy` 中 `running/paused_open_position/testing` 的实例并注册到 `RealTimeStrategyEngine`。
- 会尝试自动回填 `exchange_api_key_id`；找不到可用 API key 的策略会跳过加载。
- `StrategyRuntimeHostedService` 仍只负责启动引擎 Worker。
- 运行策略也可通过 `PATCH /api/strategy/instances/{id}/state` 即时更新。
- 涉及文件：`SeverTest/Services/StrategyRuntimeBootstrapHostedService.cs` `SeverTest/Services/StrategyRuntimeHostedService.cs`

3) **前端“数值常量比较”与后端解析不完全对齐**
- 前端会生成 `refType: "Const"` 的右值；
- 后端仅识别 `Indicator`，其余走字段解析并回落到 K 线字段默认值。
- 涉及文件：`Client/src/components/StrategyEditorFlow.tsx` `SeverTest/Services/IndicatorValueResolver.cs`

4) **开仓冲突策略未完整落地**
- `TradeActionConsumer` 当前发现已有仓位会直接忽略新开仓；
- `openConflictPolicy` 尚未应用到开仓流程。
- 涉及文件：`SeverTest/Services/TradeActionConsumer.cs` `SeverTest/Models/Strategy/StrategyModels.cs`

---

## 四、快速对照：前端生成与后端读取的配置结构

前端生成 `StrategyConfig`：
```
{
  "trade": {
    "exchange": "bitget",
    "symbol": "BTC/USDT",
    "timeframeSec": 60,
    "positionMode": "Cross",
    "openConflictPolicy": "GiveUp",
    "sizing": { "orderQty": 0.001, "maxPositionQty": 10, "leverage": 100 },
    "risk": { "takeProfitPct": 0.02, "stopLossPct": 0.01, "trailing": { ... } }
  },
  "logic": {
    "entry": { "long": { ... }, "short": { ... } },
    "exit": { "long": { ... }, "short": { ... } }
  }
}
```

后端解析并运行：
- `StrategyJsonLoader.ParseConfig()` -> `StrategyConfig`
- `RealTimeStrategyEngine` 使用 `trade + logic` 执行

涉及文件：
- `SeverTest/Services/StrategyJsonLoader.cs`
- `SeverTest/Services/RealTimeStrategyEngine.cs`

---

## 五、最小可用链路（实际运行所需）

1. 前端创建策略并保存（`/api/strategy/create`）
2. 通过 `PATCH /api/strategy/instances/{id}/state` 设置为 `running`
   - 需绑定交易所 API key（前端选择或后端自动回填）
3. 服务端行情引擎启动并产出 MarketDataTask
4. 策略引擎运行 -> 触发动作 -> 入队 -> 消费者下单

涉及文件：
- `SeverTest/Controllers/StrategyController.cs`
- `SeverTest/Services/StrategyRuntimeHostedService.cs`
- `SeverTest/Services/RealTimeStrategyEngine.cs`
- `SeverTest/Services/TradeActionConsumer.cs`

---

如需补齐：
- 启动时自动加载 running 策略
- 完整 Short 分支执行
- 数值常量解析
- OpenConflictPolicy 落地逻辑

可在此文档基础上继续扩展实现细节。
