# 策略条件缓存与任务队列设计说明

本文描述当前实盘策略运行的关键优化点：条件缓存、执行顺序与动作队列化。用于后续扩展公共筛选条件（如 ADX > 25）并降低重复计算成本。

## 目标

- 多策略共享公共条件计算结果，避免重复计算。
- 在策略加入实盘时完成条件索引构建与引用记录。
- OnPass 动作只生成任务，不直接下单。
- 保证并发安全与可控的内存使用。

## 核心做法

### 1) 条件 Key 统一化

每个条件生成唯一 Key（MD5），Key 文本包含以下维度：

- 交易所 / 币种 / 周期
- 条件方法（Method）
- 参数（args / param / offsetRange / calcMode 等）

这样相同条件在相同交易维度下只计算一次。
筛选器条件与普通条件共用同一 Key 规则，天然具备复用能力。

### 2) 条件缓存

- 缓存以 Key + K 线时间戳作为命中条件。
- 缓存内容包含：
  - 结果 bool
  - 可读字符串 Message
- 多策略复用缓存结果，避免重复计算。

### 3) 条件引用管理

- 策略入实盘时，解析其全部条件 Key 并记录引用。
- 定期清理无人引用的 Key 缓存。
- 避免缓存无限增长。
- 已增加后台清理服务 `ConditionCacheCleanupHostedService`，清理间隔由 `ConditionCache:CleanupIntervalSeconds` 配置。

### 4) 执行顺序

1. 收到 MarketDataTask
2. 计算指标（IndicatorEngine）
3. 预计算所有 Required 条件（写入缓存）
4. 开仓筛选器（Entry Filters）优先判断（仅影响开多/开空）
5. 逐容器 / 逐条件组判断（依赖缓存或计算）
6. 满足容器数量阈值后触发 onPass
7. onPass 只入队动作任务，不直接下单

### 5) 动作队列

- onPass 生成 StrategyActionTask
- 后续由专门消费者处理任务（可扩展为真实下单、通知、回放等）

## 并发与内存

- 条件缓存与引用表使用并发字典。
- 条件结果在同一时间戳下复用，避免锁争用扩大。
- 清理逻辑与计算解耦，避免阻塞策略主流程。

## 后续扩展

- 支持非交易维度的公共指标（如恐惧贪婪指数）。
- 引入定时清理服务，按引用计数或策略在线状态清理。
- 丰富任务消费逻辑（持久化、告警、回放等）。
