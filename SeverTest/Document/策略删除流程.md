# 策略删除流程说明

## 一、前端删除请求

### 1.1 请求入口
- **组件位置**：`Client/src/components/StrategyList.tsx`
- **触发方式**：用户点击删除按钮
- **请求接口**：`POST /api/strategy/delete`
- **请求参数**：
  ```typescript
  {
    usId: number  // 策略实例ID
  }
  ```

### 1.2 前端处理逻辑
```typescript
// StrategyList.tsx 第337-356行
const handleConfirmDelete = async () => {
  if (!deleteTarget || isDeleting) {
    return;
  }
  setIsDeleting(true);
  try {
    await client.post('/api/strategy/delete', { usId: deleteTarget.usId });
    showSuccess('策略删除成功');
    // 关闭历史记录对话框（如果打开）
    if (historyStrategy?.usId === deleteTarget.usId) {
      closeHistory();
    }
    closeDeleteDialog();
    await fetchStrategies(); // 刷新策略列表
  } catch (err) {
    const message = err instanceof Error ? err.message : '删除策略失败';
    showError(message);
  } finally {
    setIsDeleting(false);
  }
};
```

---

## 二、后端删除处理

### 2.1 接口位置
- **文件**：`SeverTest/Modules/StrategyManagement/Controllers/StrategyController.cs`
- **方法**：`Delete` (第1526-1563行)
- **路由**：`[HttpPost("delete")]`

### 2.2 当前实现逻辑

```csharp
[HttpPost("delete")]
public async Task<IActionResult> Delete([FromBody] StrategyDeleteRequest request)
{
    // 1. 验证用户身份
    var uid = await GetUserIdAsync();
    if (!uid.HasValue)
    {
        return Unauthorized(ApiResponse<object>.Error("未授权，请重新登录"));
    }

    // 2. 验证参数
    if (request.UsId <= 0)
    {
        return BadRequest(ApiResponse<object>.Error("无效的策略实例"));
    }

    try
    {
        // 3. 直接删除 user_strategy 记录
        using var connection = await _db.GetConnectionAsync();
        var deleteCmd = new MySqlCommand(@"
DELETE FROM user_strategy
WHERE us_id = @us_id AND uid = @uid
", connection);
        deleteCmd.Parameters.AddWithValue("@us_id", request.UsId);
        deleteCmd.Parameters.AddWithValue("@uid", uid.Value);
        var affected = await deleteCmd.ExecuteNonQueryAsync();

        if (affected == 0)
        {
            return NotFound(ApiResponse<object>.Error("未找到策略实例"));
        }

        return Ok(ApiResponse<object>.Ok(new { request.UsId }, "删除成功"));
    }
    catch (Exception ex)
    {
        Logger.LogError(ex, "删除策略失败: uid={Uid} usId={UsId}", uid.Value, request.UsId);
        return StatusCode(500, ApiResponse<object>.Error("删除失败，请稍后重试"));
    }
}
```

### 2.3 当前实现的问题

**⚠️ 重要：当前实现仅删除 `user_strategy` 表记录，未处理以下事项：**

1. **未停止运行中的策略**
   - 如果策略状态为 `running`、`paused_open_position` 或 `testing`，应该先从 `RealTimeStrategyEngine` 中移除
   - 否则策略会继续运行，但数据库记录已删除，可能导致数据不一致

2. **未处理关联表的级联删除**
   - 存在多个关联表，当前实现未清理这些关联数据
   - 如果数据库有外键约束，删除可能失败

3. **未使用事务**
   - 删除操作未使用事务，如果部分操作失败可能导致数据不一致

---

## 三、关联表清单

### 3.1 直接关联表（通过 `us_id` 字段）

| 表名 | 关联字段 | 说明 | 删除策略 |
|------|---------|------|---------|
| `strategy_position` | `us_id` | 策略仓位记录 | ❌ 未处理 |
| `strategy_import_log` | `us_id` | 导入日志（审计） | ❌ 未处理 |
| `strategy_run_check_log` | `us_id` | 运行前检查日志 | ❌ 未处理 |
| `strategy_market` | `us_id` | 策略广场记录 | ❌ 未处理 |

### 3.2 间接关联表（通过其他字段）

| 表名 | 关联字段 | 说明 | 删除策略 |
|------|---------|------|---------|
| `share_event` | `from_instance_id` / `to_instance_id` | 分享事件记录 | ❌ 未处理 |
| `official_strategy_def` | `source_us_id` | 官方策略定义（反向关联） | ❌ 未处理 |
| `template_strategy_def` | `source_us_id` | 模板策略定义（反向关联） | ❌ 未处理 |

### 3.3 引用表（不直接关联，但可能受影响）

| 表名 | 关联字段 | 说明 | 删除策略 |
|------|---------|------|---------|
| `strategy_def` | `def_id` | 策略定义（通过 `user_strategy.def_id`） | ⚠️ 需判断是否还有其他实例引用 |
| `strategy_version` | `version_id` | 策略版本（通过 `user_strategy.pinned_version_id`） | ⚠️ 需判断是否还有其他实例引用 |
| `share_code` | `share_code` | 分享码（通过 `user_strategy.share_code`） | ⚠️ 需判断是否还有其他实例使用 |

---

## 四、完整的删除流程建议

### 4.1 删除前检查

1. **检查策略状态**
   ```csharp
   // 查询策略当前状态
   SELECT state FROM user_strategy WHERE us_id = @us_id AND uid = @uid
   
   // 如果状态为 running/paused_open_position/testing，需要先停止
   ```

2. **检查是否有未平仓位**
   ```csharp
   // 查询是否有 Open 状态的仓位
   SELECT COUNT(*) FROM strategy_position 
   WHERE us_id = @us_id AND status = 'Open'
   
   // 如果有，提示用户先平仓或强制平仓
   ```

3. **检查是否被发布到官方/模板**
   ```csharp
   // 检查是否被发布到官方策略
   SELECT COUNT(*) FROM official_strategy_def WHERE source_us_id = @us_id
   
   // 检查是否被发布到模板
   SELECT COUNT(*) FROM template_strategy_def WHERE source_us_id = @us_id
   
   // 如果已发布，提示用户先移除发布
   ```

### 4.2 删除执行步骤（建议）

```csharp
[HttpPost("delete")]
public async Task<IActionResult> Delete([FromBody] StrategyDeleteRequest request)
{
    var uid = await GetUserIdAsync();
    if (!uid.HasValue)
    {
        return Unauthorized(ApiResponse<object>.Error("未授权，请重新登录"));
    }

    if (request.UsId <= 0)
    {
        return BadRequest(ApiResponse<object>.Error("无效的策略实例"));
    }

    await using var connection = await _db.GetConnectionAsync();
    await using var transaction = await connection.BeginTransactionAsync();

    try
    {
        // 1. 查询策略信息（包括状态）
        var strategyInfo = await GetStrategyInfoAsync(connection, request.UsId, uid.Value);
        if (strategyInfo == null)
        {
            return NotFound(ApiResponse<object>.Error("未找到策略实例"));
        }

        // 2. 如果策略正在运行，先从运行时引擎中移除
        if (IsRunnableState(strategyInfo.State))
        {
            _strategyEngine.RemoveStrategy(request.UsId.ToString());
        }

        // 3. 检查是否有未平仓位（可选：强制平仓或提示用户）
        var openPositions = await GetOpenPositionsCountAsync(connection, request.UsId);
        if (openPositions > 0)
        {
            // 选项1：提示用户先平仓
            // return BadRequest(ApiResponse<object>.Error($"存在 {openPositions} 个未平仓位，请先平仓"));
            
            // 选项2：强制平仓（需要实现平仓逻辑）
            // await ForceCloseAllPositionsAsync(connection, request.UsId, transaction);
        }

        // 4. 删除关联表数据（按依赖顺序）
        
        // 4.1 删除运行检查日志
        await ExecuteNonQueryAsync(connection, transaction, @"
DELETE FROM strategy_run_check_log WHERE us_id = @us_id
", new { us_id = request.UsId });

        // 4.2 删除策略广场记录
        await ExecuteNonQueryAsync(connection, transaction, @"
DELETE FROM strategy_market WHERE us_id = @us_id
", new { us_id = request.UsId });

        // 4.3 删除仓位记录（可选：保留历史记录，只标记为已删除）
        // 选项1：物理删除
        await ExecuteNonQueryAsync(connection, transaction, @"
DELETE FROM strategy_position WHERE us_id = @us_id
", new { us_id = request.UsId });
        
        // 选项2：逻辑删除（推荐，保留历史数据）
        // await ExecuteNonQueryAsync(connection, transaction, @"
        // UPDATE strategy_position 
        // SET status = 'Deleted', updated_at = CURRENT_TIMESTAMP 
        // WHERE us_id = @us_id
        // ", new { us_id = request.UsId });

        // 4.4 删除导入日志（可选：保留审计记录）
        // 注意：导入日志是审计记录，建议保留
        // await ExecuteNonQueryAsync(connection, transaction, @"
        // DELETE FROM strategy_import_log WHERE us_id = @us_id
        // ", new { us_id = request.UsId });

        // 4.5 处理分享事件（可选：保留历史记录）
        // 注意：分享事件是历史记录，建议保留，但可以标记关联的策略已删除

        // 5. 删除主表记录
        var deleteCmd = new MySqlCommand(@"
DELETE FROM user_strategy
WHERE us_id = @us_id AND uid = @uid
", connection, transaction);
        deleteCmd.Parameters.AddWithValue("@us_id", request.UsId);
        deleteCmd.Parameters.AddWithValue("@uid", uid.Value);
        var affected = await deleteCmd.ExecuteNonQueryAsync();

        if (affected == 0)
        {
            await transaction.RollbackAsync();
            return NotFound(ApiResponse<object>.Error("未找到策略实例"));
        }

        // 6. 提交事务
        await transaction.CommitAsync();

        Logger.LogInformation("策略删除成功: uid={Uid} usId={UsId}", uid.Value, request.UsId);
        return Ok(ApiResponse<object>.Ok(new { request.UsId }, "删除成功"));
    }
    catch (Exception ex)
    {
        await transaction.RollbackAsync();
        Logger.LogError(ex, "删除策略失败: uid={Uid} usId={UsId}", uid.Value, request.UsId);
        return StatusCode(500, ApiResponse<object>.Error("删除失败，请稍后重试"));
    }
}
```

### 4.3 辅助方法示例

```csharp
private async Task<StrategyInfo?> GetStrategyInfoAsync(MySqlConnection connection, long usId, long uid)
{
    var cmd = new MySqlCommand(@"
SELECT us_id, uid, state, def_id, pinned_version_id
FROM user_strategy
WHERE us_id = @us_id AND uid = @uid
", connection);
    cmd.Parameters.AddWithValue("@us_id", usId);
    cmd.Parameters.AddWithValue("@uid", uid);
    
    using var reader = await cmd.ExecuteReaderAsync();
    if (await reader.ReadAsync())
    {
        return new StrategyInfo
        {
            UsId = reader.GetInt64("us_id"),
            Uid = reader.GetInt64("uid"),
            State = reader.GetString("state"),
            DefId = reader.GetInt64("def_id"),
            PinnedVersionId = reader.GetInt64("pinned_version_id")
        };
    }
    return null;
}

private async Task<int> GetOpenPositionsCountAsync(MySqlConnection connection, long usId)
{
    var cmd = new MySqlCommand(@"
SELECT COUNT(*) FROM strategy_position
WHERE us_id = @us_id AND status = 'Open'
", connection);
    cmd.Parameters.AddWithValue("@us_id", usId);
    var result = await cmd.ExecuteScalarAsync();
    return Convert.ToInt32(result);
}

private bool IsRunnableState(string state)
{
    return state == "running" 
        || state == "paused_open_position" 
        || state == "testing";
}
```

---

## 五、数据库外键约束建议

### 5.1 当前状态
- 根据代码分析，当前数据库**可能没有设置外键约束**
- 删除 `user_strategy` 记录时，关联表的数据会变成"孤儿数据"

### 5.2 建议方案

**方案1：设置外键约束 + 级联删除**
```sql
-- 为关联表添加外键约束，设置级联删除
ALTER TABLE strategy_position 
ADD CONSTRAINT fk_strategy_position_us_id 
FOREIGN KEY (us_id) REFERENCES user_strategy(us_id) 
ON DELETE CASCADE;

ALTER TABLE strategy_run_check_log 
ADD CONSTRAINT fk_strategy_run_check_log_us_id 
FOREIGN KEY (us_id) REFERENCES user_strategy(us_id) 
ON DELETE CASCADE;

-- 注意：对于需要保留历史记录的表（如 strategy_import_log），不要设置级联删除
```

**方案2：不设置外键约束，在应用层处理**
- 优点：更灵活，可以保留历史记录
- 缺点：需要手动维护数据一致性
- **当前实现采用此方案**

---

## 六、总结

### 6.1 当前删除流程
1. ✅ 前端发送删除请求
2. ✅ 后端验证用户身份和参数
3. ✅ 直接删除 `user_strategy` 记录
4. ❌ **未停止运行中的策略**
5. ❌ **未清理关联表数据**
6. ❌ **未使用事务保证一致性**

### 6.2 风险点
1. **数据不一致**：删除策略后，运行时引擎中可能仍有该策略在运行
2. **孤儿数据**：关联表（如 `strategy_position`）中的数据会变成孤儿数据
3. **外键约束错误**：如果后续添加外键约束，删除操作可能失败
4. **历史数据丢失**：直接删除可能丢失重要的审计和历史数据

### 6.3 建议改进
1. **添加删除前检查**：检查策略状态、未平仓位、发布状态等
2. **停止运行中的策略**：从 `RealTimeStrategyEngine` 中移除
3. **使用事务**：保证删除操作的原子性
4. **选择性清理关联数据**：
   - 运行日志类数据：可以删除
   - 审计类数据（如 `strategy_import_log`）：建议保留
   - 历史数据（如 `strategy_position`）：建议逻辑删除而非物理删除
5. **添加删除确认**：对于有未平仓位或已发布的策略，要求用户确认

---

## 七、相关文件清单

### 7.1 前端文件
- `Client/src/components/StrategyList.tsx` - 策略列表和删除对话框
- `Client/src/components/StrategyDetailDialog.tsx` - 策略详情对话框（包含删除按钮）

### 7.2 后端文件
- `SeverTest/Modules/StrategyManagement/Controllers/StrategyController.cs` - 删除接口实现
- `SeverTest/Modules/StrategyEngine/Application/RealTimeStrategyEngine.cs` - 运行时策略引擎
- `SeverTest/Modules/StrategyRuntime/Application/StrategyRuntimeBootstrapHostedService.cs` - 策略启动服务

### 7.3 数据库相关
- `SeverTest/Modules/Positions/Infrastructure/StrategyPositionRepository.cs` - 仓位仓储
- `SeverTest/Modules/StrategyEngine/Infrastructure/StrategyRunCheckLogRepository.cs` - 检查日志仓储

### 7.4 文档
- `SeverTest/Document/策略系统.md` - 策略系统整体说明
- `SeverTest/Document/实盘仓位管理.md` - 仓位管理说明
- `SeverTest/Document/策略运行前检查系统.md` - 运行前检查说明
