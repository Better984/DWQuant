# 实盘仓位管理精简版（DWQuant）

> **范围**：仅满足以下两点最小需求：
> 1) 服务端存储所有策略的开仓，并提供 API 按策略实例ID或用户ID+时间范围查询仓位状态（未平仓/已平仓/是否触发移动止盈）。
> 2) 对未平仓仓位进行实时行情检查（止盈/止损/移动止盈），触发后通过 ccxt 执行平仓。

---

## 0. 与现有项目结构的对齐

- 行情：`MarketDataEngine`（可用 `GetLatestKline` 获取最新 OHLC）。
- 策略触发：`RealTimeStrategyEngine` → `StrategyActionTaskQueue`。
- 下单执行：现有 `CcxtStrategyActionExecutor` 为 DryRun，需要切换为真实下单。
- **最小新增模块**：
  - `TradeActionConsumer`（消费动作队列，落地仓位）
  - `PositionRiskEngine`（轮询最新行情，触发风控平仓）

> 为避免 `MarketDataTask` 多消费者分流丢事件，本精简方案**不额外订阅通道**，而是由 `PositionRiskEngine` 定时从 `MarketDataEngine.GetLatestKline` 拉取最新 OHLC。

---

## 1. 最小数据库结构（只保留 1 张表）

### 1.1 strategy_position（仓位主表）
**用途**：记录每次开仓与仓位状态（是否平仓、是否触发移动止盈）。

**必需字段（最小集合）**
- `position_id`：PK
- `uid`：用户ID
- `us_id`：策略实例ID
- `exchange` / `symbol`
- `side`：Long/Short
- `entry_price` / `qty`
- `status`：Open/Closed
- `stop_loss_price` / `take_profit_price`
- `trailing_enabled` / `trailing_triggered` / `trailing_stop_price`
- `opened_at` / `closed_at`

**SQL（对齐现库风格，最小版本）**
```sql
CREATE TABLE strategy_position (
  position_id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '仓位ID',
  uid BIGINT UNSIGNED NOT NULL COMMENT '用户ID',
  us_id BIGINT UNSIGNED NOT NULL COMMENT '策略实例ID',

  exchange VARCHAR(32) NOT NULL COMMENT '交易所',
  symbol VARCHAR(32) NOT NULL COMMENT '交易对',
  side VARCHAR(8) NOT NULL COMMENT '方向: Long/Short',

  entry_price DECIMAL(18,8) NOT NULL COMMENT '开仓均价',
  qty DECIMAL(18,8) NOT NULL COMMENT '持仓数量',

  status VARCHAR(16) NOT NULL COMMENT '状态: Open/Closed',

  stop_loss_price DECIMAL(18,8) NULL COMMENT '止损价',
  take_profit_price DECIMAL(18,8) NULL COMMENT '止盈价',

  trailing_enabled TINYINT(1) NOT NULL DEFAULT 0 COMMENT '是否启用移动止盈',
  trailing_stop_price DECIMAL(18,8) NULL COMMENT '移动止损价',
  trailing_triggered TINYINT(1) NOT NULL DEFAULT 0 COMMENT '是否触发移动止盈',

  opened_at DATETIME(3) NOT NULL COMMENT '开仓时间',
  closed_at DATETIME(3) NULL COMMENT '平仓时间',

  PRIMARY KEY (position_id),
  INDEX idx_uid_time (uid, opened_at),
  INDEX idx_usid_time (us_id, opened_at),
  INDEX idx_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC;
```

---

## 2. 最小 API 规范

### 2.1 按用户查询仓位
`GET /api/positions?uid=123&from=2026-01-01&to=2026-01-31&status=all`

**Response.Data**
```json
{
  "items": [
    {
      "positionId": 10001,
      "uid": 123,
      "usId": 456,
      "exchange": "binance",
      "symbol": "BTC/USDT",
      "side": "Long",
      "status": "Open",
      "entryPrice": 42000.5,
      "qty": 0.01,
      "stopLossPrice": 41000.0,
      "takeProfitPrice": 45000.0,
      "trailingEnabled": true,
      "trailingTriggered": false,
      "trailingStopPrice": 43200.0,
      "openedAt": "2026-01-27 16:01:00",
      "closedAt": null
    }
  ]
}
```

### 2.2 按策略实例查询仓位
`GET /api/positions/by-strategy?usId=456&from=2026-01-01&to=2026-01-31&status=all`

**Response.Data**：同上

---

## 3. 风控逻辑（最小实现）

### 3.1 止盈/止损
- **Long**：
  - 止盈：`price >= take_profit_price`
  - 止损：`price <= stop_loss_price`
- **Short**：
  - 止盈：`price <= take_profit_price`
  - 止损：`price >= stop_loss_price`

### 3.2 移动止盈（Trailing）
以 Long 为例：
- 记录 `max_favorable_price`
- 计算 `trailing_stop_price = max_favorable_price * (1 - drawdown_pct)`
- 触发：`price <= trailing_stop_price`

Short 逻辑相反。

---

## 4. 最小执行流程

1. **策略触发**：`RealTimeStrategyEngine` 生成动作任务。
2. **TradeActionConsumer** 消费任务 → 真实下单 → 写入 `strategy_position`。
3. **PositionRiskEngine** 定时检查所有 `status=Open` 仓位：
   - 从 `MarketDataEngine.GetLatestKline(exchange, symbol, timeframe)` 获取最新价格
   - 执行止盈/止损/移动止盈判断
   - 触发后调用 ccxt 平仓，更新仓位为 `Closed`

---

## 5. 最小代码模块草图

### 5.1 TradeActionConsumer（动作队列消费者）
```csharp
public sealed class TradeActionConsumer : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        await foreach (var task in _queue.ReadAllAsync(stoppingToken))
        {
            // 解析 action
            // ccxt 下单
            // 写入 strategy_position
        }
    }
}
```

### 5.2 PositionRiskEngine（风控轮询）
```csharp
public sealed class PositionRiskEngine : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            var openPositions = await _repo.ListOpenPositionsAsync();
            foreach (var pos in openPositions)
            {
                var kline = _marketDataEngine.GetLatestKline(pos.Exchange, pos.Timeframe, pos.Symbol);
                // 判断 TP/SL/Trailing -> ccxt 平仓 -> 更新仓位
            }
            await Task.Delay(TimeSpan.FromSeconds(1), stoppingToken);
        }
    }
}
```

---

## 6. 必须最小改动点

- **补齐动作任务字段**：`StrategyActionTask` 至少需要 `uid/us_id/exchange/symbol/side/qty`，否则无法落地仓位。
- **Ccxt 实盘执行**：现有 `CcxtStrategyActionExecutor` 是 DryRun，必须实现真实下单。
- **仓位表落地**：新增 `strategy_position` 表即可满足最小需求。

---

> 这是“最小可用”的实盘仓位管理方案，满足你的两个核心需求，不引入额外复杂模块。

---

## 7. 风控高性能索引方案（可选优化）

> **目标**：仓位数大幅增长后，避免 `PositionRiskEngine` 每秒全量扫描；用“价格区间树索引”把候选仓位缩小到少量集合。

### 7.1 核心思路
- 每个交易对维护独立索引（SymbolRiskIndex）。
- 以“价格区间”而非单点价格触发检查，覆盖一秒内剧烈波动造成的跨桶跳跃。
- 将止盈/止损/移动止盈拆成多类索引，分别查询、合并候选仓位。

### 7.2 价格区间构建（解决跨桶跳跃问题）
- 每秒拉取一次最新 K 线（1m），使用 **区间** 而不是收盘价，并引入上一轮价格：
  - `rangeLow = min(prevPrice, lastPrice, kline.low ?? lastPrice)`
  - `rangeHigh = max(prevPrice, lastPrice, kline.high ?? lastPrice)`
- 这样即使 1 秒内出现 “2499.3 → 2530 → 2500.3” 的急剧波动，也会完整覆盖 `[2499.3, 2530]`。
- 可选：记录上次高低点避免重复扫描，但即使重复也能通过“仓位状态判定”保证幂等。

### 7.3 多层树结构（按价格数量级自适应）
- 使用 **三层桶**（粗/中/细），仅对存在仓位的桶建节点，避免预分配。
- 步长建议按数量级自适应：
  - `baseStep = 10 ^ (floor(log10(price)) - 1)`
  - `L1 = baseStep`，`L2 = baseStep / 10`，`L3 = baseStep / 100`
- 示例：
  - 价格 3500 → `L1=100` `L2=10` `L3=1`
  - 价格 80000 → `L1=1000` `L2=100` `L3=10`
  - 价格 0.00758 → `L1=0.0001` `L2=0.00001` `L3=0.000001`
- 若交易所提供 **TickSize**，可将 `L3` 下限对齐到 TickSize。

### 7.4 索引类型（分治减少扫描）
- **止损索引**（StopLossIndex）：按止损价入树。
- **止盈索引**（TakeProfitIndex）：按止盈价入树。
- **移动止盈触发索引**（TrailingStopIndex）：按当前移动止盈价入树。
- **移动止盈激活索引**（TrailingActivationIndex）：按激活价入树。
- **移动止盈更新索引**（TrailingUpdateIndex）：按“下一次更新阈值价”入树。

### 7.5 移动止盈的高效更新
- 问题：价格上涨（或下跌）时，若每秒全量更新所有移动止盈，会再次退化为 O(N)。
- 方案：为每个仓位维护 **下一次更新阈值价**：
  - Long：当 `price > currentStop / (1 - drawdownPct)` 才需要更新。
  - Short：当 `price < currentStop / (1 + drawdownPct)` 才需要更新。
- 将“下一次更新阈值价”作为索引键，只有触发阈值的仓位才更新并重建索引。
- 更新时使用区间极值一次性推进：
  - Long：`newStop = max(currentStop, rangeHigh * (1 - drawdownPct))`
  - Short：`newStop = min(currentStop, rangeLow * (1 + drawdownPct))`

### 7.6 触发流程（伪流程）
1. **开仓入库**：计算止盈/止损/激活价，写入对应索引。
2. **每秒检查**：
   - 取 `rangeLow/rangeHigh`（见 7.2）。
   - 在索引中查询覆盖区间的桶，得到候选仓位集合。
   - 逐个仓位做精确判定，触发则下单并移除索引。
3. **移动止盈**：
   - 先查询激活索引，达到激活价则初始化移动止盈价并转入 `TrailingStopIndex`。
   - 再查询更新索引，只更新需要更新的仓位（见 7.5）。

### 7.7 复杂度与收益
- 传统：`O(N)` 全量扫描。
- 新方案：`O(k + m)`（k 为桶数量，m 为候选仓位数量），N 很大时优势明显。
- 内存换性能：索引只保存必要键，不预分配，内存可控。

### 7.8 启动与一致性
- 启动时加载所有 `Open` 仓位，构建索引。
- 触发后立即移除索引，避免重复触发。
- 若订单失败或状态异常，按仓位状态/DB 回查兜底。
